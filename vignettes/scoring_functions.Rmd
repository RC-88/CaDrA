---
title: "Scoring Functions"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Scoring Functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(message=FALSE, collapse = TRUE, comment="")
library(CaDrA)
library(SummarizedExperiment)
```

The **CaDrA** package currently provides four scoring functions to search for subsets of genomic features that are likely associated with a specific outcome of interest (e.g., protein expression, pathway activity, etc.)

1. Kolmogorov-Smirnov Method (`ks`)
2. Conditional Mutual Information Method (`revealer`)
3. Wilcoxon Rank-Sum Method (`wilcox`)
4. Custom - User Provided Scoring Function (`custom`)

**Important Note:**

- To search for the best meta-feature over the top N starting seed features, see `?candidate_search()` or `?topn_eval()`
- The legacy function `topn_eval()` is equivalent to the recommended `candidate_search()`.

Below, we run candidate search over the top 7 starting seed features using each of the four scoring functions described above.

# Load packages

```r
library(CaDrA)
library(SummarizedExperiment)
```

# Load required datasets

1. A `binary features matrix` also known as `Feature Set` (such as somatic mutations, copy number alterations, chromosomal translocations, etc.) The 1/0 vectors indicate the presence/absence of ‘omics’ features in the samples. The `Feature Set` must be an object of class **RangedSummarizedExperiment** from **SummarizedExperiment** package) 
2. A vector of continuous scores (or `input_score`) representing a functional response of interest (such as protein expression, pathway activity, etc.)

```{r load.data}

# Load pre-computed expression set
data(sim_FS)
 
# Load pre-computed input-score
data(sim_Scores)

```

# Kolmogorov-Smirnov scoring method 

See `?ks_rowscore` for more details

```{r ks.method}

ks_topn_l <- CaDrA::candidate_search(
  FS = sim_FS,
  input_score = sim_Scores,
  method = "ks",               # Use Kolmogorow-Smirnow scoring function 
  weight = NULL,               # If weight is provided, it will be used to perform a weighted-KS test
  alternative = "less",        # Use one-sided p-value
  metric = "pval",             # Use p-value to search for best feature
  search_method = "both",      # Apply both forward and backward search
  top_N = 7,                   # Evaluate top 7 starting points for the search
  max_size = 10,               # Set max_size = 10 to allow at most 10 features in meta-feature
  do_plot = FALSE,             # We will plot it AFTER finding the best hits
  best_score_only = FALSE,     # If best_score_only = FALSE, it will return meta-feature Eset, 
                               # its observed input scores and corresponding best score
)

# Now we can fetch the ESet of top feature that corresponded to the best scores over the top N search
ks_topn_best_meta <- topn_best(ks_topn_l)

# Visualize best meta-feature result
meta_plot(topn_best_list = ks_topn_best_meta)

```

# Wilcoxon Rank-Sum scoring method 

See `?wilcox_rowscore` for more details

```{r wilcox.method}

wilcox_topn_l <- CaDrA::candidate_search(
  FS = sim_FS,
  input_score = sim_Scores,
  method = "wilcox",           # Use Wilcoxon Rank-Sum scoring function
  alternative = "less",        # Use one-sided p-value
  metric = "pval",             # Use p-value to search for best feature
  search_method = "both",      # Apply both forward and backward search
  top_N = 7,                   # Evaluate top 7 starting points for the search
  max_size = 10,               # Set max_size = 10 to allow at most 10 features in meta-feature
  do_plot = FALSE,             # We will plot it AFTER finding the best hits
  best_score_only = FALSE      # If best_score_only = FALSE, it will return meta-feature Eset, 
                               # its observed input scores and corresponding best score
)

# Now we can fetch the ESet of top feature that corresponded to the best scores over the top N search
wilcox_topn_best_meta <- topn_best(topn_list = wilcox_topn_l)

# Visualize best meta-feature result
meta_plot(topn_best_list = wilcox_topn_best_meta)

```

# Conditional Mutual Information scoring method 

See `?revealer_rowscore` for more details

```{r revealer.method}

revealer_topn_l <- CaDrA::candidate_search(
  FS = sim_FS,
  input_score = sim_Scores,
  method = "revealer",         # Use REVEALER's CMI scoring function
  metric = "stat",             # Use score statistics to search for best feature
  search_method = "both",      # Apply both forward and backward search
  top_N = 7,                   # Evaluate top 7 starting points for the search
  max_size = 10,               # Set max_size = 10 to allow at most 10 features in meta-feature
  do_plot = FALSE,             # We will plot it AFTER finding the best hits
  best_score_only = FALSE      # If best_score_only = FALSE, it will return meta-feature Eset, 
                               # its observed input scores and corresponding best score
)

# Now we can fetch the ESet of top feature that corresponded to the best scores over the top N search
revealer_topn_best_meta <- topn_best(topn_list = revealer_topn_l)

# Visualize best meta-feature result
meta_plot(topn_best_list = revealer_topn_best_meta)

```

# Custom - user provided scoring method

See `?custom_rowscore` for more details

```{r custom.method}

# A customized function using ks-test function
customized_rowscore <- function(FS, input_score, alternative){
  
  result <- apply(FS, 1, function(r){ 
    x = input_score[which(r==1)]; 
    y = input_score[which(r==0)];
    res <- ks.test(x, y, alternative=alternative)
    return(c(res$statistic, res$p.value))
  })
  
  # Convert list to data.frame
  dat <- data.frame(score=result[1,], p_value=result[2,])
  rownames(dat) <- rownames(ES)
  
  return(dat)
  
}

# Search for best features using a custom-defined function
custom_topn_l <- CaDrA::candidate_search(
  FS = sim_FS,
  input_score = sim_Scores,
  custom_function = customized_rowscore,            # Use a customized scoring function
  custom_parameters = list(alternative = "less"),   # Additional parameters to pass to custom_function
  metric = "pval",                                  # Use pval to search for best feature
  search_method = "both",                           # Apply both forward and backward search
  top_N = 7,                                        # Evaluate top 7 starting points for the search
  max_size = 10,                                    # Set max_size = 10 to allow at most 10 features in meta-feature
  do_plot = FALSE,                                  # We will plot it AFTER finding the best hits
  best_score_only = FALSE                           # If best_score_only = FALSE, it will return meta-feature Eset, 
                                                    # its observed input scores and corresponding best score
)

# Now we can fetch the ESet of top feature that corresponded to the best scores over the top N search
custom_topn_best_meta <- topn_best(topn_list = custom_topn_l)

# Visualize best meta-feature result
meta_plot(topn_best_list = custom_topn_best_meta)

```

